
import pytest
import os
import json
from unittest.mock import patch, MagicMock
from datetime import datetime, timezone

from retail_os.core.marketplace_adapter import MarketplaceAdapter
from retail_os.scrapers.onecheq.scraper import scrape_onecheq_product
from retail_os.core.unified_schema import normalize_onecheq_row

FIXTURE_DIR = os.path.join(os.path.dirname(__file__), "fixtures/scrapers")

def load_fixture(supplier, filename):
    path = os.path.join(FIXTURE_DIR, supplier, filename)
    with open(path, "r", encoding="utf-8") as f:
        return f.read()

def test_daily_canary_flow(db_session, tmp_path):
    """
    Deterministic Canary:
    1. Scrapes fixture (OneCheq).
    2. Enriches via LLM Stub.
    3. Backfills images via Stub.
    4. Builds Listing Payload.
    5. Outputs Report.
    """
    
    # 1. Scrape Fixture (Stub Network)
    html_content = load_fixture("onecheq", "product.html")
    with patch("retail_os.scrapers.onecheq.scraper.get_html_via_httpx", return_value=html_content):
        # Must pass client=None to trigger usage of simple mocked fetch if internal logic differs?
        # scrape_onecheq_product handles client=None.
        raw_data = scrape_onecheq_product("https://onecheq.co.nz/products/canary-item")
    
    assert raw_data is not None, "Scrape fixture failed"
    
    # 2. Normalize
    unified = normalize_onecheq_row(raw_data)
    unified["source_category"] = "canary-collection"
    
    # Unified schema from normalize_onecheq_row uses photo1, photo2 etc.
    images_list = [
        unified.get("photo1"), unified.get("photo2"), 
        unified.get("photo3"), unified.get("photo4")
    ]
    images_list = [x for x in images_list if x]
    
    # 3. Simulate DB Persist
    from retail_os.core.database import SupplierProduct, Supplier
    s = Supplier(id=99, name="CANARY_SUPPLIER", base_url="http://canary")
    db_session.add(s)
    db_session.flush()
    
    sp = SupplierProduct(
        supplier_id=99,
        external_sku="CANARY-001",
        title=unified["title"],
        description=unified["description"],
        cost_price=unified["buy_now_price"],
        images=images_list,
        specs=unified["specs"],
        source_category="test-cat",
        snapshot_hash="abc",
        last_scraped_at=datetime.now(timezone.utc)
    )
    db_session.add(sp)
    db_session.commit()
    db_session.refresh(sp) # Ensure relationships/fields are loaded
    
    # Force relationship association in session for test reliability
    sp.supplier = s
    
    # 4. Enrich & Prepare (Stub LLM & Images)
    with patch("retail_os.core.llm_enricher.LLMEnricher.enrich_product") as mock_llm:
        mock_llm.return_value = {
            "title": "Enriched Canary Product",
            "description": "Better description generated by AI.",
            "features": ["F1", "F2"],
            "specs": {"Brand": "FixtureBrand"}
        }
        
        # Enriched Data setup (simulate enrichment job)
        sp.enriched_title = "Enriched Canary Product"
        sp.enriched_description = "Better description generated by AI."
        sp.technical_specs = {"Brand": "FixtureBrand"}
        
        # 5. Build Payload (MarketplaceAdapter)
        # Needs Mocks for CategoryMapper and ImageGuard
        with patch("retail_os.core.category_mapper.CategoryMapper.map_category", return_value="0001-0002"):
            with patch("retail_os.core.category_mapper.CategoryMapper.get_category_name", return_value="Mobile Phones"):
                with patch("retail_os.core.image_guard.guard.check_image", return_value={"is_safe": True, "reason": "Mocked"}):
                     with patch("retail_os.core.image_guard.guard.is_active", return_value=True):
                        # Mock Config
                         with patch("retail_os.trademe.config.TradeMeConfig.MODE", "STANDARD"):
                             # Ensure local file check in ImageGuard doesn't crash if we provide paths that don't exist
                             # We can mock os.path.exists inside MarketplaceAdapter logic if needed, 
                             # or just mock guard.check_image which we did.
                             
                             # MarketplaceAdapter calls PricingStrategy.calculate_price(item.cost_price, ..., supplier_name)
                             # sp.supplier.name should be CANARY_SUPPLIER.
                             
                             payload = MarketplaceAdapter.prepare_for_trademe(sp)
            
    # 6. Validation
    # Keys from MarketplaceAdapter are lowercase
    assert payload["title"] == "Enriched Canary Product" 
    assert payload["description"].startswith("Better description")
    # Price check: Cost ~199. Margin > 5%. Price > 210.
    assert payload["price"] > 200.0
    
    # 7. Report Generation
    report = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "status": "PASS",
        "payload_snapshot": payload
    }
    
    report_path = os.path.join(os.path.dirname(__file__), "../data/canary_report.json")
    os.makedirs(os.path.dirname(report_path), exist_ok=True)
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
